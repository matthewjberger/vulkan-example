#version 460
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_ARB_gpu_shader_int64 : require

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

struct DrawCommand {
    uint indexCount;
    uint instanceCount;
    uint firstIndex;
    int vertexOffset;
    uint firstInstance;
};

struct Object {
    vec4 position;
    vec4 color;
    uint meshIndex;
    uint materialIndex;
    uint padding1;
    uint padding2;
};

struct MeshData {
    uint vertexOffset;
    uint vertexCount;
    uint indexOffset;
    uint indexCount;
};

struct Frustum {
    vec4 planes[6];
};

layout(buffer_reference, std430) readonly buffer ObjectBuffer {
    Object objects[];
};

layout(buffer_reference, std430) writeonly buffer DrawCommandBuffer {
    DrawCommand drawCommands[];
};

layout(buffer_reference, std430) writeonly buffer CountBuffer {
    uint drawCount;
};

layout(buffer_reference, std430) readonly buffer MeshBuffer {
    MeshData meshes[];
};

layout(buffer_reference, std430) buffer VisibilityBuffer {
    uint visible[];
};

layout(push_constant) uniform PushConstants {
    uint objectCount;
    uint meshCount;
    uvec2 vertexBufferAddress;
    uvec2 objectBufferAddress;
    uvec2 meshBufferAddress;
    uvec2 indirectBufferAddress;
    uvec2 countBufferAddress;
    uvec2 visibilityBufferAddress;
    mat4 viewMatrix;
    mat4 projectionMatrix;
    uint enableFrustumCulling;
    uint padding1;
    uint padding2;
};

const float OBJECT_RADIUS = 1.0;

bool isSphereInFrustum(vec3 center, float radius, Frustum frustum) {
    for (int i = 0; i < 6; i++) {
        vec4 plane = frustum.planes[i];
        float dist = dot(vec3(plane.xyz), center) + plane.w;

        if (dist < -radius) {
            return false;
        }
    }
    return true;
}

Frustum extractFrustum(mat4 viewProj) {
    Frustum frustum;

    frustum.planes[0].x = viewProj[3][0] + viewProj[0][0];
    frustum.planes[0].y = viewProj[3][1] + viewProj[0][1];
    frustum.planes[0].z = viewProj[3][2] + viewProj[0][2];
    frustum.planes[0].w = viewProj[3][3] + viewProj[0][3];

    frustum.planes[1].x = viewProj[3][0] - viewProj[0][0];
    frustum.planes[1].y = viewProj[3][1] - viewProj[0][1];
    frustum.planes[1].z = viewProj[3][2] - viewProj[0][2];
    frustum.planes[1].w = viewProj[3][3] - viewProj[0][3];

    frustum.planes[2].x = viewProj[3][0] + viewProj[1][0];
    frustum.planes[2].y = viewProj[3][1] + viewProj[1][1];
    frustum.planes[2].z = viewProj[3][2] + viewProj[1][2];
    frustum.planes[2].w = viewProj[3][3] + viewProj[1][3];

    frustum.planes[3].x = viewProj[3][0] - viewProj[1][0];
    frustum.planes[3].y = viewProj[3][1] - viewProj[1][1];
    frustum.planes[3].z = viewProj[3][2] - viewProj[1][2];
    frustum.planes[3].w = viewProj[3][3] - viewProj[1][3];

    frustum.planes[4].x = viewProj[3][0] + viewProj[2][0];
    frustum.planes[4].y = viewProj[3][1] + viewProj[2][1];
    frustum.planes[4].z = viewProj[3][2] + viewProj[2][2];
    frustum.planes[4].w = viewProj[3][3] + viewProj[2][3];

    frustum.planes[5].x = viewProj[3][0] - viewProj[2][0];
    frustum.planes[5].y = viewProj[3][1] - viewProj[2][1];
    frustum.planes[5].z = viewProj[3][2] - viewProj[2][2];
    frustum.planes[5].w = viewProj[3][3] - viewProj[2][3];

    for (int i = 0; i < 6; i++) {
        float len = length(frustum.planes[i].xyz);
        frustum.planes[i] /= len;
    }

    return frustum;
}

void main() {
    uint64_t objAddr = packUint2x32(objectBufferAddress);
    uint64_t meshAddr = packUint2x32(meshBufferAddress);
    uint64_t drawAddr = packUint2x32(indirectBufferAddress);
    uint64_t countAddr = packUint2x32(countBufferAddress);
    uint64_t visibilityAddr = packUint2x32(visibilityBufferAddress);

    ObjectBuffer objectBuffer = ObjectBuffer(objAddr);
    MeshBuffer meshBuffer = MeshBuffer(meshAddr);
    DrawCommandBuffer drawCommandBuffer = DrawCommandBuffer(drawAddr);
    CountBuffer countBuffer = CountBuffer(countAddr);
    VisibilityBuffer visibilityBuffer = VisibilityBuffer(visibilityAddr);

    if (gl_GlobalInvocationID.x == 0) {
        if (objectCount == 0) {
            countBuffer.drawCount = 0;
            return;
        }

        for (uint i = 0; i < meshCount; i++) {
            visibilityBuffer.visible[i] = 0;
        }
    }

    barrier();

    mat4 viewProj = projectionMatrix * viewMatrix;
    Frustum frustum = extractFrustum(viewProj);

    for (uint i = gl_GlobalInvocationID.x; i < objectCount; i += gl_WorkGroupSize.x * gl_NumWorkGroups.x) {
        Object obj = objectBuffer.objects[i];
        uint meshIndex = obj.meshIndex;

        bool isVisible = true;

        if (enableFrustumCulling == 1) {
            vec3 position = obj.position.xyz;
            isVisible = isSphereInFrustum(position, OBJECT_RADIUS, frustum);
        }

        if (isVisible) {
            atomicAdd(visibilityBuffer.visible[meshIndex], 1);
        }
    }

    barrier();

    if (gl_GlobalInvocationID.x == 0) {
        uint commandCount = 0;
        uint currentFirstInstance = 0;

        for (uint meshIndex = 0; meshIndex < meshCount; meshIndex++) {
            uint instanceCount = visibilityBuffer.visible[meshIndex];

            if (instanceCount > 0) {
                MeshData mesh = meshBuffer.meshes[meshIndex];

                drawCommandBuffer.drawCommands[commandCount].indexCount = mesh.indexCount;
                drawCommandBuffer.drawCommands[commandCount].instanceCount = instanceCount;
                drawCommandBuffer.drawCommands[commandCount].firstIndex = mesh.indexOffset;
                drawCommandBuffer.drawCommands[commandCount].vertexOffset = int(mesh.vertexOffset);
                drawCommandBuffer.drawCommands[commandCount].firstInstance = currentFirstInstance;

                commandCount++;
                currentFirstInstance += instanceCount;
            }
        }

        countBuffer.drawCount = commandCount;
    }
}